# -*- coding: utf-8 -*-
"""Overtaking_Classification _Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DYAlFtUo7IVrQ3Q9wV9nj6z2samB3f-n
"""

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  VEHICLE-CATEGORY SUMMARY GENERATOR  Â·  v1.0
#  (for â€œFinal_Overtaking_Summary_With_Overtaken_ID*.csvâ€
#   and â€œFinal_Merged_Trajectory.csvâ€ / â€œProcessed_Vehicles.csvâ€)
#
#  â€¢ Tags every vehicle as:
#       â€“ â€œOvertaking with oncoming vehiclesâ€
#       â€“ â€œOvertaking without oncoming vehiclesâ€
#       â€“ â€œNo overtaking and in lane with oncoming vehiclesâ€
#       â€“ â€œFree flowingâ€
#  â€¢ Outputs  Vehicle_Category_Summary.csv  and auto-downloads it
#  â€¢ Shows a pretty preview table in-notebook
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# STEP 1 â”€â”€ IMPORTS
import pandas as pd, numpy as np, io, re
from google.colab import files

# STEP 2 â”€â”€ UPLOAD FILES
print("ğŸ“‚  Upload the overtaking-summary CSV and the trajectory CSV:")
uploads = files.upload()

# STEP 3 â”€â”€ LOCATE THE REQUIRED FILES
ovt_path, veh_path = None, None
for name in uploads:
    lname = name.lower()
    if re.search(r'overtaking.*summary', lname):
        ovt_path = name
    if ('processed_vehicles' in lname) or ('final_merged_trajectory' in lname):
        veh_path = name

if ovt_path is None:
    raise ValueError("Couldnâ€™t locate an overtaking-summary CSV in your upload.")
if veh_path is None:
    raise ValueError("Couldnâ€™t locate a vehicle-trajectory CSV in your upload.")

# STEP 4 â”€â”€ READ THE CSVs
overtaking_df = pd.read_csv(io.BytesIO(uploads[ovt_path]))
vehicle_df    = pd.read_csv(io.BytesIO(uploads[veh_path]))

# Normalise column names
overtaking_df.columns = overtaking_df.columns.str.strip()
vehicle_df.columns    = vehicle_df.columns.str.strip()

# STEP 5 â”€â”€ HANDLE POSSIBLE COLUMN-NAME VARIANTS
# (a) Opposing-vehicle list during overtake
for cand in ['Opposing_Vehicles_During_Overtake',
             'Opposing_Vehicle_IDs',
             'Opposing_Vehicles',
             'OppVehicleIDs']:
    if cand in overtaking_df.columns:
        opp_col = cand
        break
else:
    opp_col = 'Opposing_Vehicles_During_Overtake'
    overtaking_df[opp_col] = ''          # create blank if truly absent

# (b) Centre-line distance column
for cand in ['Distance from centreline', 'Distance_from_Centreline',
             'distance from centreline', 'distance_from_centreline']:
    if cand in vehicle_df.columns:
        dist_col = cand
        break
else:
    raise ValueError("No centreline-distance column found in trajectory data.")

# STEP 6 â”€â”€ CATEGORISE OVERTAKING VEHICLES
overtaking_df[opp_col] = overtaking_df[opp_col].fillna('').astype(str)
overtaking_df['Category'] = np.where(
    overtaking_df[opp_col].str.strip() != '',
    'Overtaking with oncoming vehicles',
    'Overtaking without oncoming vehicles'
)

# STEP 7 â”€â”€ CATEGORISE NON-OVERTAKING VEHICLES
all_ids        = vehicle_df['VehicleID'].unique()
overtaking_ids = overtaking_df['Overtaking_Vehicle_ID'].unique()
non_ids        = np.setdiff1d(all_ids, overtaking_ids)

threshold = 1.5  # metres from centreline deemed â€œin laneâ€

def classify_non_overtaker(vid):
    mean_dev = vehicle_df.loc[vehicle_df['VehicleID'] == vid, dist_col].abs().mean()
    return ('No overtaking and in lane with oncoming vehicles'
            if mean_dev <= threshold else
            'Free flowing')

non_df = pd.DataFrame({'VehicleID': non_ids})
non_df['Category'] = non_df['VehicleID'].map(classify_non_overtaker)

# STEP 8 â”€â”€ MERGE RESULTS
ovt_res = overtaking_df[['Overtaking_Vehicle_ID', 'Category']].rename(
            columns={'Overtaking_Vehicle_ID': 'VehicleID'})
final_df = (
    pd.concat([ovt_res, non_df], ignore_index=True)
      .sort_values('VehicleID', kind='mergesort')
      .reset_index(drop=True)
)

# STEP 9 â”€â”€ SAVE & DOWNLOAD
out_name = 'Vehicle_Category_Summary.csv'
final_df.to_csv(out_name, index=False)
files.download(out_name)

# STEP 10 â”€â”€ OPTIONAL: PRETTY PREVIEW
try:
    styled = (
        final_df.style
        .set_table_styles([{'selector': 'th',
                            'props': [('font-weight', 'bold'),
                                      ('background-color', '#d4d4d4')]}])
        .apply(lambda col: ['background-color: #f7f7f7' if i % 2 else ''
                            for i in range(len(col))], axis=0)
    )
    styled
except:
    pass